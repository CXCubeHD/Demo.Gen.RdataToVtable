use std::{
    collections::HashMap,
    error::Error,
    fs::File,
    io::{BufWriter, Write},
};

use r2v_parser::Gen;

pub fn generate_cpp(gen: &Gen) -> Result<String, Box<dyn Error>> {
    let mut ss = BufWriter::new(Vec::new());

    writeln!(ss, "struct {}_Vftable", gen.r#type)?;
    writeln!(ss, "{{")?;

    let mut methods_hash_table1 = HashMap::<&str, usize>::new();
    gen.methods.iter().for_each(|m| {
        if m.name.is_empty() {
            return;
        }

        methods_hash_table1.insert(
            m.name.as_str(),
            *methods_hash_table1.get(m.name.as_str()).unwrap_or(&0) + 1,
        );
    });
    methods_hash_table1.retain(|_, s| *s > 1);
    let mut methods_hash_table2 = methods_hash_table1
        .iter()
        .map(|(m, s)| (*m, (*s, *s)))
        .collect::<HashMap<&str, (usize, usize)>>();

    for (i, m) in gen.methods.iter().enumerate() {
        let is_last = i == (gen.methods.len() - 1);
        let line = |stream: &mut BufWriter<Vec<u8>>| -> Result<(), Box<dyn Error>> {
            if !is_last {
                writeln!(stream)?
            }
            Ok(())
        };

        let mut occured_temp = (0, 0);
        let (occured_counter, occured_count) = methods_hash_table2
            .get_mut(m.name.as_str())
            .unwrap_or(&mut occured_temp);

        if m.name.trim().is_empty() {
            writeln!(ss, "\tvoid* _{};", m.index)?;
            // line(&mut ss)?;
            continue;
        }

        if m.name.starts_with("`") {
            writeln!(ss, "\tvoid* _{};", m.index)?;
            // line(&mut ss)?;
            continue;
        }

        // writeln!(
        //     ss,
        //     "\t/// `{}::{}` at index **{}**",
        //     gen.scoped_type, m.name, m.index
        // )?;
        // writeln!(ss, "\t///")?;
        // for (i, p) in m.parameter_types.iter().enumerate() {
        //     if p.is_empty() {
        //         writeln!(ss, "\t/// **@param{i}** \\")?;
        //         continue;
        //     }
        //     writeln!(ss, "\t/// **@param{i}** `{p}` \\")?;
        // }
        // if m.return_type.is_empty() {
        //     writeln!(ss, "\t/// **@returns** `void`")?;
        // } else {
        //     writeln!(ss, "\t/// **@returns** `{}`", m.return_type)?;
        // }
        // writeln!(ss, "\t///")?;
        // writeln!(ss, "\t/// This method was autogenerated.")?;
        // writeln!(ss, "\t///")?;
        // writeln!(ss, "\t/// # Generated")?;
        // if !m.undecorated_symbol.is_empty() {
        //     writeln!(ss, "\t/// Undecorated Symbol:")?;
        //     writeln!(ss, "\t/// ```cpp")?;
        //     writeln!(ss, "\t/// {}", m.undecorated_symbol)?;
        //     writeln!(ss, "\t/// ```")?;
        //     writeln!(ss, "\t///")?;
        // }
        // writeln!(ss, "\t/// Raw Symbol:")?;
        // writeln!(ss, "\t/// ```raw")?;
        // writeln!(ss, "\t/// {}", m.symbol)?;
        // writeln!(ss, "\t/// ```")?;

        let mut args = String::new();
        for (i, p) in m.parameter_types.iter().enumerate() {
            args.push_str(p.trim());
            if i != m.parameter_types.len() - 1 {
                args.push_str(", ");
            }
        }

        if *occured_counter == 0 {
            writeln!(ss, "\t{} (*{})({});", m.return_type, m.name, args)?;
        } else {
            writeln!(
                ss,
                "\t{} (*{}_{})({});",
                m.return_type,
                m.name,
                (*occured_count - *occured_counter),
                args
            )?;
            *occured_counter -= 1;
        }
        // line(&mut ss)?;
    }
    writeln!(ss, "}}")?;

    return Ok(String::from_utf8(ss.into_inner().unwrap())?);
}
